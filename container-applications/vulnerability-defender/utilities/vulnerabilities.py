import pymysql
from google.cloud import runtimeconfig, datastore
from random import randrange

LEVEL1_POINTS = 15
LEVEL2_POINTS = 30

vulnerable_assets = [
    {'name': 'Network Switch', 'vendor': 'cisco', 'product': 'ios'},
    {'name': 'CEO Workstation', 'vendor': 'google', 'product': 'chrome'},
    {'name': 'Phone', 'vendor': 'google', 'product': 'android'},
    {'name': 'Web Server', 'vendor': 'apache', 'product': 'tomcat'},
    {'name': 'Email Server', 'vendor': 'oracle', 'product': 'email_center'},
    {'name': 'SCADA System', 'vendor': 'microsoft', 'product': 'windows_10'},
    {'name': 'Database System', 'vendor': 'oracle', 'product': 'mysql'},
    {'name': 'SharePoint System', 'vendor': 'microsoft', 'product': 'sharepoint_enterprise_server'},
    {'name': 'HR Manager Workstation', 'vendor': 'apple', 'product': 'icloud'},
    {'name': 'Firewall', 'vendor': 'paloaltonetworks', 'product': 'pan-os'}
]


def get_vulnerability(workout_id):
    """
    Selects a vulnerability from the NVD database at random for a specified workout
    :param workout_id: Used for tracking the selected vulnerability
    :returns: Data structure containing the vulnerability database fields from the NVD
    """
    runtimeconfig_client = runtimeconfig.Client()
    myconfig = runtimeconfig_client.config('cybergym')
    mysql_password = myconfig.get_variable('sql_password').value.decode("utf-8")
    mysql_ip = myconfig.get_variable('sql_ip').value.decode("utf-8")

    ds_client = datastore.Client()
    workout = ds_client.get(ds_client.key('cybergym-workout', workout_id))

    dbcon = pymysql.connect(host=mysql_ip,
                                 user="root",
                                 password=mysql_password,
                                 db='cybergym',
                                 charset='utf8mb4')
    dbcur = dbcon.cursor()

    tries = 0
    while tries < 100:
        asset_index = randrange(9)

        select_vuln_query = """
            SELECT nvd.cve_id, nvd.attack_vector, nvd.complexity, nvd.priv, nvd.ui, nvd.confidentiality, nvd.integrity, 
                        nvd.availability, nvd.description
            FROM nvd_data nvd
            WHERE nvd.vendor = %s AND nvd.product = %s"""

        vuln_args = (vulnerable_assets[asset_index]['vendor'], vulnerable_assets[asset_index]['product'])
        dbcur.execute(select_vuln_query, vuln_args)
        vuln_index = randrange(dbcur.rowcount)
        i = 0
        for v in dbcur:
            if i == vuln_index:
                if 'response' in workout['assessment'] and 'vulnerabilities' in workout['assessment']['response'] \
                        and v[0] in workout['assessment']['response']['vulnerabilities']:
                    i += 1
                    break
                else:
                    return_vuln = {
                        'asset': vulnerable_assets[asset_index]['name'],
                        'cve_id': v[0],
                        'description': v[8],
                        'attack_vector': v[1],
                        'complexity': v[2],
                        'priv': v[4],
                        'confidentiality': v[5],
                        'integrity': v[6],
                        'availability': v[7]
                    }
                    return return_vuln
            i += 1
    return None


def assess_response(organization, vulnerability, response):
    """
    :param vulnerability:
    :param response:
    :returns:
    """
    impact_ordering = {'NONE': 0, 'LOW': 1, 'HIGH': 2}
    reverse_ordering = ['NONE', 'LOW', 'HIGH']

    confidentiality = min(impact_ordering[organization['service_impact']],
                          impact_ordering[organization['confidentiality_impact']],
                          impact_ordering[vulnerability['v_confidentiality']])
    integrity = min(impact_ordering[organization['service_impact']],
                    impact_ordering[organization['integrity_impact']],
                    impact_ordering[vulnerability['v_integrity']])
    availability = min(impact_ordering[organization['service_impact']],
                       impact_ordering[organization['availability_impact']],
                       impact_ordering[vulnerability['v_availability']])

    correct_answer = max(confidentiality, integrity, availability)
    response = impact_ordering[response]
    test = correct_answer == response
    if test:
        points = correct_answer + 1
    else:
        points = 0 - (correct_answer + 1)

    return {
        'correct': test,
        'correct_answer': reverse_ordering[correct_answer],
        'points': points
    }


def get_score_image(score):
    """
    Returns the image to display based on the given score
    """
    score_img_prefix = "/static/imgs/trojan"
    if score <= 0 - LEVEL1_POINTS:
        img_num = 0
    elif score < -5:
        img_num = 1
    elif score < 5:
        img_num = 2
    elif score < LEVEL1_POINTS:
        img_num = 3
    else:
        img_num = 4

    return f"{score_img_prefix}-{img_num}.png"
